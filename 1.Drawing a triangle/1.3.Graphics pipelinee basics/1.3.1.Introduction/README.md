# Introduction

다음 몇 개의 챕터에 걸쳐, 우리의 첫 삼각형을 그리기 위해 설정된 그래픽 파이프라인을 구축할 것입니다. 그래픽 파이프라인은 메쉬의 정점(vertex)과 텍스처를 렌더 타겟의 픽셀로 변환하는 일련의 작업을 수행하는 과정입니다. 이 과정을 단순화한 개요는 아래와 같습니다:

![image02](../../../Image/image02.png)

**입력 어셈블러(Input Assembler)**는 지정한 버퍼에서 원시 정점 데이터를 수집하며, 인덱스 버퍼를 사용해 정점 데이터를 중복 저장하지 않고도 특정 요소를 반복해서 사용할 수 있습니다.

**정점 셰이더(Vertex Shader)**는 각 정점에 대해 실행되며, 일반적으로 정점 위치를 모델 공간에서 화면 공간으로 변환하는 변환을 적용합니다. 또한, 정점별 데이터를 파이프라인 아래 단계로 전달합니다.

**테셀레이션 셰이더(Tessellation Shaders)**는 특정 규칙에 따라 기하학을 세분화하여 메쉬 품질을 높이는 데 사용됩니다. 이는 벽돌 벽이나 계단과 같은 표면이 가까이 있을 때 덜 평면적으로 보이도록 만드는 데 자주 사용됩니다.

**기하 셰이더(Geometry Shader)**는 각 기본 도형(삼각형, 선, 점)마다 실행되며, 이를 폐기하거나 입력보다 더 많은 기본 도형을 출력할 수 있습니다. 이는 테셀레이션 셰이더와 유사하지만 훨씬 더 유연합니다. 그러나 대부분의 그래픽 카드에서는 성능이 좋지 않아서, Intel 통합 GPU를 제외하고는 오늘날의 애플리케이션에서 많이 사용되지 않습니다.

**래스터화 단계(Rasterization Stage)**는 기본 도형을 화면의 픽셀 단위로 분할하여 프래그먼트(Fragment)로 만듭니다. 이 프래그먼트는 프레임버퍼(Frame Buffer)에서 채워지는 픽셀 요소를 의미합니다. 화면을 벗어나는 프래그먼트는 삭제되며, 정점 셰이더가 출력한 속성은 프래그먼트 전체에 걸쳐 보간(interpolation)됩니다. 일반적으로, 다른 기본 도형 프래그먼트 뒤에 있는 프래그먼트는 깊이 테스트(Depth Testing)로 인해 이 단계에서 폐기됩니다.

**프래그먼트 셰이더(Fragment Shader)**는 삭제되지 않고 남은 각 프래그먼트에 대해 호출되며, 프래그먼트를 어느 프레임버퍼에 기록할지, 그리고 어떤 색상 및 깊이 값을 사용할지를 결정합니다. 이는 정점 셰이더로부터 보간된 데이터를 사용하여 수행할 수 있으며, 여기에는 텍스처 좌표나 조명을 위한 노멀과 같은 정보가 포함될 수 있습니다.

**색상 블렌딩 단계(Color Blending Stage)**는 동일한 픽셀에 매핑되는 서로 다른 프래그먼트를 혼합하는 작업을 수행합니다. 프래그먼트는 단순히 서로를 덮어쓰거나 더하거나, 투명도를 기준으로 혼합될 수 있습니다.

초록색으로 표시된 단계는 **고정 기능 단계(Fixed-Function Stages)**로 알려져 있습니다. 이 단계들은 매개변수를 사용하여 동작을 조정할 수 있지만, 동작 방식 자체는 사전에 정의되어 있습니다.

반면 주황색으로 표시된 단계는 **프로그래머블 단계(Programmable Stages)**로, 원하는 작업을 정확히 적용할 수 있도록 사용자가 자신의 코드를 그래픽 카드에 업로드할 수 있습니다. 이를 통해 예를 들어, 프래그먼트 셰이더를 사용하여 텍스처링, 조명부터 레이 트레이싱에 이르기까지 다양한 작업을 구현할 수 있습니다. 이러한 프로그램들은 GPU의 많은 코어에서 동시에 실행되어 정점(Vertex)과 프래그먼트(Fragment)와 같은 여러 객체를 병렬로 처리할 수 있습니다.

OpenGL이나 Direct3D와 같은 이전 API를 사용해본 경험이 있다면, `glBlendFunc`나 `OMSetBlendState`와 같은 호출을 통해 파이프라인 설정을 자유롭게 변경할 수 있었던 것에 익숙할 것입니다. 하지만 Vulkan의 그래픽스 파이프라인은 거의 완전히 **불변(Immutable)**이며, 셰이더를 변경하거나 다른 프레임버퍼를 바인딩하거나 블렌드 함수를 변경하려면 파이프라인을 처음부터 다시 생성해야 합니다.

이로 인해 렌더링 작업에서 사용하고자 하는 다양한 상태 조합을 나타내는 여러 개의 파이프라인을 만들어야 한다는 단점이 있습니다. 그러나 파이프라인에서 수행될 모든 작업이 사전에 알려져 있기 때문에 드라이버가 이를 훨씬 더 효율적으로 최적화할 수 있다는 장점이 있습니다.

프로그래머블 단계 중 일부는 수행하려는 작업에 따라 선택적입니다. 예를 들어, 간단한 기하학을 그리는 경우에는 **테셀레이션(세분화)**과 지오메트리 셰이더(Geometry Shader) 단계를 비활성화할 수 있습니다. 깊이 값만 필요하다면 프래그먼트 셰이더(Fragment Shader) 단계를 비활성화할 수 있으며, 이는 [그림자 맵](https://en.wikipedia.org/wiki/Shadow_mapping) 생성에 유용합니다.

다음 챕터에서는 화면에 삼각형을 그리는 데 필요한 두 개의 프로그래머블 단계를 먼저 생성합니다: **버텍스 셰이더(Vertex Shader)**와 **프래그먼트 셰이더(Fragment Shader)**입니다. 그 후 챕터에서는 블렌딩 모드, 뷰포트, 래스터화와 같은 고정 기능 구성도 설정할 것입니다. Vulkan에서 그래픽스 파이프라인을 설정하는 마지막 부분은 입력 및 출력 프레임버퍼의 사양을 지정하는 것입니다.

`createGraphicsPipeline` 함수를 작성하고, `createImageViews`가 호출된 후 `initVulkan`에서 이를 호출하도록 합니다. 우리는 이 함수에 대해 다음 챕터들에서 계속 작업할 것입니다.

```C++
void initVulkan() {
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
    createImageViews();
    createGraphicsPipeline();
}

...

void createGraphicsPipeline() {

}
```

## Source Code
- [C++ code](https://vulkan-tutorial.com/code/08_graphics_pipeline.cpp)
